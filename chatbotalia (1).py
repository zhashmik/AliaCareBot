# -*- coding: utf-8 -*-
"""ChatbotAlia.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pnz1Ga5v36E8VuMxuDENkkxjscwUuBvG

# LAST REVISED DATE: 2025-01-10
# CREATED DATE: 2025-01-10
#
# CREATED BY: Zahra Hashmi Khamgaowala
#
#
# PROGRAM PURPOSE: This program allows a user to talk to an AI psychotherapist.
#    The program takes the user input, and either asks for the user to restate
#    the input, or the psychotherapist provides a resonse to keep the conversation
#    going.
#
# PROGRAM DEPENDENCIES:
#          1) Python version 3.0 or greater
#          2) Installed libraries of re, random, string, nltk.tokenize
#
# INPUTS:  This program relies on inputs from the user. When the program runs,
#          a prompt is issued to the user and the user responds. To quit the
#          program, the user types 'quit'.
#          For example, when the program begins, the user will see a prompt
#          asking them what their name is.  The user will respond with their
#          name and then type enter.
#
# OUTPUTS: The program responds by providing a response to the user, and
#          converses with the user to try to delve into their psychological
#          problems.
#          For example, when the psychotherapist receives input, the program
#          will loop through logic to determine how to respond.
#
# MAIN PROGRAM FLOW:
#          1) The program prompts the user for their name.
#             a) The name is validated. If the program is confident a name is found
#                processing continues to the conversational section of the code.
#             b) If the name is not validated, the system reprompts the user and
#                tries to be more specific to help them respond.
#          2) Once the conversation area is reached:
#             a) The system takes the input from the user and performs validations
#                on it to determine if it will be able to understand the text.
#                i) If the system may have trouble interpretting, for example
#                   because there are too many sentences or too few words, the user
#                   is prompted to enter their thought again.
#                ii)If input is formatted "correctly", then the system starts to
#                   determine the correct response.
#             b) To respond to the user, the program maps the pronouns used and
#                determines the pronouns to respond with. Additionally, it takes
#                the language and determines a correct response back to the user.
#
# SPECIAL FEATURES:
#          1) While typing 'quit' ends the program, if the user types 'exit', the program
#             recognizes that the user likely wants to quit. However, instead of immediately
#             ending, the program gently guides the user by saying, "If you want to quit,
#             please type 'quit'. This ensures the user understands the correct command to
#             end the session."
#          2) There is much code around capturing the user's name in case user accidently adds
#             some non-string character to their name. Since knowing
#             your patient is important, we wanted to make sure it is captured
#             correctly.
#
"""

# Import all necessary libraries needed.
!pip install nltk
import nltk
nltk.download('punkt_tab')

import re, random
from nltk.tokenize import sent_tokenize, word_tokenize
import string

#Global variables - theese are used to distinquish who is talking.
DATA_ENTRY_IND=">> "
BOT_NAME="ALIA: "

class TherapistAlia:
    def __init__(self):
        self.name_determined=False
        self.username = ''
#This is the dictionary of pronouns that are mapped.
        self.pronoun_map =                   {
          'either': 'which', 'everybody': 'they', 'everyone': 'they', 'everything': '', 'few': '', 'he': 'he',
    'her': 'her', 'herself': 'herself', 'him': 'him', 'himself': 'himself', 'his': 'his', 'i': 'you',
    'it': 'it', 'itself': 'itself', 'me': 'you', 'mine': 'yours', 'my': 'your', 'myself': 'yourself',
    'our': 'your', 'ourselves': 'yourselves', 'ours': 'yours', 'she': 'she', 'that': 'this', 'their': 'their',
    'theirs': 'theirs', 'them': 'them', 'themselves': 'themselves', 'these': 'those', 'they': 'they',
    'this': 'that', 'those': 'these', 'thou': 'thee', 'thy': 'thine', 'us': 'you all', 'we': 'you all',
    'ye': 'ye', 'you': 'i', 'yourself': 'myself', 'yourselves': 'ourselves', 'yours': 'ours', 'all': 'all',
    'another': 'another', 'any': 'any', 'anybody': 'anybody', 'anyone': 'anyone', 'anything': 'anything',
    'both': 'both', 'each': 'each', 'many': 'many', 'neither': 'neither', 'no one': 'no one', 'nobody': 'nobody',
    'none': 'none', 'noone': 'noone', 'nothing': '', 'one': 'one', 'other': 'other', 'others': '', 'several': '',
    'most': 'most', 'some': 'some', 'somebody': 'somebody', 'someone': 'someone', 'something': 'something',
    'such': 'such'
}

# This QnA dictionary stores differnt patterns and various responses for different types of user input.
        self.QnA = {
            r'i feel (.*)': [
                'It’s important to acknowledge how you feel. Can you share more about why you’re feeling %s?',
                'I hear you. Feeling %s can be challenging. What’s been contributing to this?',
                'Let’s talk through this together. How long have you been feeling %s?'
            ],
            r'i want (.*)': [
                'That’s a meaningful desire. What steps do you think could help you get closer to %s?',
                'It sounds like %s is really important to you. How can we work through any challenges together?',
                'What would achieving %s bring into your life? Let’s explore this further.'
            ],
            r'my (.*)': [
                'Your %s seems to hold a lot of significance for you. Can you tell me more?',
                'How does your %s play a role in your current situation or feelings?',
                'I’d like to understand your %s better. How has it been impacting you?'
            ],
            r'i think (.*)': [
               'Thinking about %s sounds interesting. Can you elaborate on why you feel this way?',
               'You think %s—what makes you say that? Let’s discuss it.',
               'It’s good to express your thoughts. What led you to think about %s?',
            ],
            r'(.*) mother(.*)': [
                'Your relationship with your mother sounds important. How has it been affecting you lately?',
                'What’s one thing about your mother that stands out to you right now?',
                'Let’s talk about your mother. What feelings or thoughts come up when you think about her?'
            ],
            r'(.*) father(.*)': [
                'Fathers can influence us deeply. How has your father been a part of your journey?',
                'What’s a memory of your father that feels significant to you right now?',
                'How do you feel when you think about your father? Let’s reflect on that together.'
            ],
            r'(.*) parents(.*)': [
                'How do you feel when you think about your parents?',
                'How have your parents influenced your decisions?',
                'What would you like to share about your relationship with your parents?'
            ],
            r'(.*) mom(.*)': [
                'Thinking about your mom, what emotions come up for you?',
                'How has your mom supported or impacted you in your life?',
                'What would you like to share about your relationship with your mom?'
            ],
            r'(.*) dad(.*)': [
                'Your dad seems to be on your mind. What’s been your experience with him lately?',
                'What’s something you appreciate about your dad? Let’s explore that.',
                'How has your relationship with your dad shaped how you’re feeling now?'
            ],
            r'(.*) friend(.*)': [
                'Friends can be such a vital support system. How has your friend been there for you?',
                'What’s something about your friend that you’re grateful for right now?',
                'Let’s talk about your friend. How have they influenced your life recently?'
            ],
            r'(.*) brother(.*)': [
                'Brothers can be such a source of strength or challenge. How do you feel about your relationship with your brother?',
                'What’s something about your brother that’s been on your mind lately?',
                'How has your brother influenced the way you see things? Let’s talk about it.'
            ],
            r'(.*) sister(.*)': [
                'Your sister seems important to you. What’s a recent moment with her that stands out?',
                'What’s something about your sister that brings you comfort or joy?',
                'Let’s talk about your sister. How does your relationship with her shape your feelings?'
            ],
            r'(.*) sad(.*)': [
                "I’m so sorry to hear you’re feeling sad. What’s been contributing to this sadness?",
                "It’s okay to feel sad sometimes. Would you like to share what’s been on your mind?",
                "Let’s take a moment to understand this together. What’s been weighing on your heart?"
            ],
            r'(.*) happy(.*)': [
                "That’s wonderful to hear. What’s been bringing you this happiness?",
                "Happiness is so valuable. Can you tell me what’s making you feel this way?",
                "Let’s celebrate this joy together. What’s been adding positivity to your life?"
            ],
            r'(.*) like (.*)': [
                'It’s great to hear about things you enjoy. What’s special about %s for you?',
                'Liking %s sounds meaningful. How does it add value or joy to your life?',
                'Tell me more about %s. What’s something that makes it stand out for you?'
            ],
            r'(.*) hate (.*)': [
                'It’s tough to deal with things we dislike. What about %s feels difficult for you?',
                'Hating %s must be weighing on you. Can you share more about what’s causing these feelings?',
                'Let’s talk about %s. How does it affect you or your day-to-day life?'
            ],
            r'i love (.*)': [
                'Love is such a powerful emotion. What do you cherish most about %s?',
                'Loving %s must bring a lot of meaning to your life. What makes it so special?',
                'Let’s explore this love together. How has %s positively influenced you?'
            ],
            r'i miss (.*)': [
                'Missing %s shows how much they or it means to you. Want to share more about why you’re feeling this way?',
                'It’s okay to miss %s—it’s a sign of love or value. How are you coping with these feelings?',
                'I hear you. Missing %s can be hard. Would talking about them or it help you feel a bit better?'
            ]
        }

        self.memory = {}

    # This function replaces the pronoun sent by the user with the correct pronoun to use in the response.
    def replace_pronouns(self, text):
        return ' '.join([self.pronoun_map.get(w.upper(), w) for w in text.split()])

    def store_memory(self, user_input):
        words = user_input.lower().split()
        for word in words:
            if word not in self.memory:
                self.memory[word] = user_input

    def recall_memory(self, user_input):
        words = user_input.lower().split()
        for word in words:
            if word in self.memory:
                return f"I remember you said: '{self.memory[word]}'. Can you tell me more?"
        return None

    #this section is the main "pre-processor" of the input text. It tries to catch problems that we know
    #would overwhelm our functionality, and then we ask the user to restate.
    def evaluate_text(self,user_input):
        #Check sentence length
        if not self.text_one_sentence(user_input):
            if self.name_determined:
                return "Sorry " + self.username+", you used too many sentences and I didn't understand. Try again?"
            else:
                return "That was a lot to take in. Let's try going slower. This time, state your name, one word only."

        #Check that words exceeds two
        if self.text_is_too_short(user_input):
            return self.username+ ", can you rephrase and use a few more words?"

        #Check that text was given
        if user_input=="":
          #  return "It's going to be very hard to help you if you won't talk to me."
            if self.name_determined==False:
                return f"It's going to be very hard to help you if you won't talk to me. \nIt's easy to take the first step. Just tell me your first name."
            else:
                return "It's going to be very hard to help you if you won't talk to me."

        #Check for gibberish - function code needs to be added to it
        if self.text_is_gibberish(user_input):
           return "It seems like you're speaking gibberish. Please try again in English."

        # if we made it here, then all validations passed of the input data and now it
        # can be processed for a response. It indicates that we have determined the users name.
        if not self.name_determined:
            self.name_determined=True

            tokenized_words=word_tokenize(user_input)
            num_of_words=len(tokenized_words)

            # Checking for some specific patterns to extract the correct name from user's sentence
            # We assume if only one word is entered, this is the name.
            # Next, we added some common ways a user may enter their name.
            # If the none of those conditions were true, we assume the name is the last
            # word in the sentence.
            # Finally, we make sure there is no puncuation as we don't want to call them "Bill."
            if num_of_words ==1:
                self.username=user_input.lower()
            elif 'my name is' in user_input.lower():
                self.username = user_input.lower().split('my name is')[-1].strip()
            elif 'my first name is' in user_input.lower():
                self.username = user_input.lower().split('my first name is')[-1].strip()
            elif 'call me' in user_input.lower():
                self.username= user_input.lower().split('call me')[-1].strip()
            else:
                self.username=tokenized_words[num_of_words-1] #last word hopefully

            #remove any punctuations from the entered name
            self.username = self.username.translate(str.maketrans('', '', string.punctuation))

            # Format name so first letter is capitalized and rest are lower case
            name_length=len(self.username)
            self.username=self.username[0].upper()+self.username[1:name_length].lower()
            return("My new friend "+ self.username+", I am Dr. Alia. Nice to meet you. Before we "+
                "begin our session today, there are some rules I insist all patients follow. "+
                "First, I ask that you only state or ask one thought at a time. Second, if at any time you "+
                "want to end our session, just type 'quit'. Now, what do you want to talk about?")
        else:
            return(self.process_input(user_input))

    # This function determines the number of sentences passed in.
    # If the patient provided more than one sentence, false is returned.
    def text_one_sentence(self,user_input):
        tokenized_sentences=len(sent_tokenize(user_input))
        if tokenized_sentences>1:
            return False
        else:
            return True

    # This function ensures that we have enough words for a valid sentence.
    # It also checks to see if we know the name. In that situation there may
    # only be one word provided.
    def text_is_too_short(self,user_input):
        # If it is a name one word is fine, but otherwise more should be
        # spoken and there should be actual words, etc.
        tokenized_words=len(word_tokenize(user_input))
        if self.name_determined:
            if tokenized_words<2:
                return True
        else:
            return False

    # This function checks for gibberish or random characters enter by the user.
    def text_is_gibberish(self, user_input):
        pattern = r"^[a-zA-Z\s.,!?'-]+$"

        return not bool(re.match(pattern, user_input.strip()))

    # After the inbound text has been validated, now the response is being prepared.
    def process_input(self, user_input):
        cleaned_input = re.sub(r'[!?,.]', '', user_input.lower())

       # memory_response = self.recall_memory(cleaned_input)
       # if memory_response:
       #    return memory_response

        for pattern, responses in self.QnA.items():
            if matched := re.search(pattern, cleaned_input, re.I):
                selected = random.choice(responses)

                self.store_memory(cleaned_input)

                return selected.replace("%s", self.replace_pronouns(matched.groups()[-1]))
        self.store_memory(cleaned_input)
        follow_up_questions = [
                 f"Could you share more details about this, my friend {self.username}?",
                 f"I'd love to hear more about this, {self.username}.",
                 f"What else can you share about this, {self.username}?",
                 f"Hmm, interesting. Tell me more, {self.username}!"
        ]
        return random.choice(follow_up_questions)
#==============================================================================================
#MAIN PROCESSING BEGINS HERE
#==============================================================================================

    # Prompt the user
    def begin_session(self):

        print(BOT_NAME,"Welcome to Psychotherapist Alia: Healing starts with a chat, and we're all ears!\nCan you tell me your first name?(Ps: hit the enter key after you provide this.)")

        # We want to make sure we successfully determine the name of the user. Users can enter a
        # name in a variety of ways. So, after the name is entered, we go to evaluate the text.
        while not self.name_determined:
            self.username = input(DATA_ENTRY_IND).strip()

            print(BOT_NAME, self.evaluate_text(self.username))

        # This section of the code is reached once the name has been validated. It checks to see
        # a response is provided and that the user has not decided to quit. If none of those
        # occurred, the text is evaluated and then a response is processed.
        while True:
            user_msg = input(f"{self.username.upper()}: ").strip()
            if not user_msg:
                print(BOT_NAME,"Do not be shy, my friend.")
                continue
            if 'exit' in user_msg.lower():
                print(BOT_NAME,"If you are trying to leave, remember you have to type QUIT!")
                continue
            if 'quit' in user_msg.lower():
                print(BOT_NAME,"Thanks for talking to me. If you want more specialized conversation, try "
                      "talking to my brother", random.choice(["ChatGPT", "DeepSeek"]), ".")
                break

            print (BOT_NAME, self.evaluate_text(user_msg))


if __name__ == '__main__':
    chatbot = TherapistAlia()
    chatbot.begin_session()